#### 1、什么是类加载？

* 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后再堆区创建一个java.lang.Class对象，用来封装来在方法区的数据结构。
* 类的加载最终是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供访问方法区的数据机构的接口。

#### 2、类加载器

* 启动类加载器（Bootstarp ClassLoader），负责加载存放在JDK/jre/lib下，或被-Xbootclasspath参数指定路径的，并且能被虚拟机识别的类库。
* 扩展类加载器（Extension ClassLoader），该加载器有sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK/jre/bin/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
* 应用程序类加载器（Application ClassLoader），该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。
* 自定义类加载器（contextClassLoader）
  * 为了解决父类加载器因为某些原因需要加载低层的类而创建的类加载器（上下文类加载器）

#### 3、什么场景下需要自定义类加载器？

* 加载特定路径的class文件
* 加载一个加密的网络文件
* 热部署加载class文件

#### 4、JVM加载class文件的过程（原理）？

* 当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备、解析）和初始化。
* 类的加载是把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不可用。
* 当类被加载后就进入链接阶段，这一阶段包含验证（确保被加载类能够满足java虚拟机的约束）、准备（为静态变量分配内存并设置默认的初始值）、解析（符合引用替换为直接引用）三个步骤。
* 最后JVM对类进行初始化。
  * 当虚拟机启动时，初始化用户指定的主类
  * 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类
  * 当遇到调用静态方法指令、静态字段指令时，初始化该静态字段所在的类
  * 子类的初始化会触发父类的初始化
  * 如果一个接口定义了default方法，那么直接实现或间接实现该接口的类初始化，会触发该接口的初始化
  * 使用反射API对某个类进行反射调用时，初始化这个类
  * 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。

#### 5、JVM内存分区

* 方法区（Method Area）
  * 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
* 堆（Heap）
  * 是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。
* 栈（Stacks）
  * PC寄存器（Program Counter Register）
    * 是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
  * java方法栈
    * 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。java虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行时都会同时创建一个栈桢（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中从入栈到出栈的过程。
  * 本地方法栈（Native Method Stacks）
    * 本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈是为虚拟机使用到的Native方法服务的。

#### 6、什么是GC？为什么要有GC?

* GC是垃圾收集的意思，内存处理是变成人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动检测对象是否超过作用域从而达到自动回收内存的目的。

#### 7、都有哪些垃圾回收器？

* 新生代收集器
  * Serial收集器，单线程，采用标记复制算法
  * Parallel New收集器，就是Serial收集器的多线程版本，采用标记复制算法
  * Parallel Scavenge收集器，类似Parallel New收集器，它更关注吞吐量，采用标记复制算法
* 老年代收集器
  * Serial Old收集器，单线程，采用标记压缩算法
  * Parallel Old收集器，Serial Old收集器的多线程版本，采用标记压缩算法
  * CMS收集器，并发收集器，采用标记清除算法

* G1(garbage first)

  * G1是一个横跨新生代和老年代的垃圾收集器。G1已经打乱了前面所说的堆结构，直接将堆分成极其多的区域，每个区域都可以是Eden区、Survivor区或者老年代的一个。跟CMS收集器一样都能够在程序运行过程中并发的进行垃圾回收。采用标记-压缩算法。

  * G1能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是G1名字的由来。

  * 参数详情

    ![img](https://upload-images.jianshu.io/upload_images/2015574-07106dc0f17975a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/974/format/webp)

#### 8、如何判断一个对象是存是亡？

* 引用计数法

  * 做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡。
  * 存在循环引用的问题，导致其内存空间不可回收，从而造成内存泄漏。

* 可达性分析

  * 实质在于一系列GC Roots作为初始的存活对象集合（live set），然后从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。
  * GC Roots 
    * Java方法栈桢中的局部变量
    * 已加载类的静态变量
    * JNI handles
    * 已启动未停止的Java线程

  * 可达性分析，可以解决引用计数法中存在的循环引用问题。

#### 9、垃圾回收算法

* 标记 - 清除
* 标记 - 压缩
* 复制

#### 10、引用的分类

* 强引用：GC是不会被回收
* 软引用：描述有用但不是必须的对象，在发生内存溢出异常之前被回收
* 弱引用：描述有用但不是必须的对象，在下一次GC时被回收
* 虚引用（幽灵/幻影引用）：无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用用来在GC时返回一个通知。

#### 11、调优命令

* Sun JDK监控和故障处理命令有jps、jstat、jmap、jhat、jstack、jinfo
  * jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
  * jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
  * jmap，JVM Memory Map命令用于生成heap dump文件
  * jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看
  * jstack，用于生成java虚拟机当前时刻的线程快照。
  * jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。

#### 12、java内存模型

* ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

* 主内存和工作内存之间的交互

* 

* | 操作   | 作用对象 | 解释                                                         |
  | ------ | -------- | ------------------------------------------------------------ |
  | lock   | 主内存   | 把一个变量标识为一条线程独占的状态                           |
  | unlock | 主内存   | 把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定   |
  | read   | 主内存   | 把一个变量的值从主内存传输到线程工作内存中，以便load操作使用 |
  | load   | 工作内存 | 把read操作从主内存中得到的变量直接放入工作内存中             |
  | use    | 工作内存 | 把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时会执行这个操作 |
  | assing | 工作内存 | 把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 |
  | store  | 工作内存 | 把工作内存中的一个变量的值传递到主内存中，一边writer操作     |
  | write  | 工作内存 | 把store操作从工作内存中得到的变量的值放入主内存的变量中      |

* 对于volatile变量的特殊规则

  * 可见性（Visibility）
    * 指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。
  * 有序性
    * 禁止指令重排

* 对于long和double型变量的特殊规则
  * java要求对于主内存之间的八个操作都是原子性的，但是对于64位的数据类型，有一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read、和write这4个操作的原子性。这就是long和double的非原子性协定。

* happens-before原则

  * 这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是Java内存模型中定义的两项操作之间的偏序关系。

  * 天然的先行发生关系

  * 

  * | 规则             | 解释                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | 程序次序规则     | 在一个线程内，代码按照书写的控制流顺序执行                   |
    | 管程锁定规则     | 一个unlock操作先行发送与后面对同一个锁的lock操作             |
    | volatile变量规则 | volatile变量的写操作先行发生于后面对这个变量的读操作         |
    | 线程启动规则     | Thread对象的start()方法先行发生于此线程的每一个动作          |
    | 线程终止规则     | 线程中所有的操作都先行发生于对此线程的终止检测（通过Thread.join()方法结束、Thread.isAlive()的返回值检测） |
    | 对象终结规则     | 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始 |
    | 传递性           | 如果操作A优先于操作B发生，操作B先于操作C发生，那么操作A先于操作C |
    |                  |                                                              |

